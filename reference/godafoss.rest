

.. raw:: pdf

    PageBreak coverPage


.. image:: images/godafoss-waterfalls.jpg
   :width: 1800
   :alt: Godafoss waterfall

Godafoss reference


.. raw:: pdf

    PageBreak oneColumn

.. header:: Godafoss reference

.. contents::

.. footer:: page ###Page###

.. sectnum::



.. raw:: pdf

    PageBreak oneColumn

*****
hx711
*****

implemented in: library/chips/gf-hx711.hpp



---------------------------------


[>hx711<]

This template implements an interface to the
hx711 24-Bit Analog-to-Digital Converter (ADC).
This chip is intended to interface to a load cell (force sensor).

:: 

  template<
     pin_out_compatible  _sck,
     pin_in_compatible   _dout,
     typename            timing
  >
  struct hx711 {
     enum class mode {
        a_128  = 1,  // A inputs, gain 128
        b_32   = 2,  // B inputs, gain 32
        a_64   = 3   // A inputs, gain 64
     };
     static void init( mode m = mode::a_128 ){ ... }
     static int32_t read(){ ... }
     static void power_down(){ ... }
     static void mode_set( mode m ){ ... }
  };
  


The chip interface consist of a master-to-slave clock pin (sck),
and a slave-to-master data pin (dout).

The timing is used for the waits as required by the hx711 datasheet.

The mode offers a choice between the A differential inputs with
a gain of 128 or 64, and the B inputs with a gain of 32.
The A inputs are meant to be used with a load cell.
The datasheet suggest that the B inputs could be used to monitior
the battery voltage.
The mode is set at the initialization (the defauylt is a_128),
and can be changed by the mode_set() function.

The chip can be powered down. When a read is done the chip
is first (automatically) powered up.

[>hd44780_rs_e_d_s_timing<]


.. raw:: pdf

    PageBreak oneColumn

*******
hd44780
*******

implemented in: library/chips/gf-hd44780.hpp



---------------------------------


The hd44780 template implements a charcater terminal
on an hd44780 character lcd.

:: 

  template<
     pin_out_compatible   rs,
     pin_out_compatible   e,
     port_out_compatible  port,
     xy<>                 size,
     typename             timing
  > using hd44780_rs_e_d_s_timing = { ... };
  


The rs, e and port must connect to the corresponding pins of the lcd.
The lcd is used in 4-bit mode, so the port must connect to the
d0..d3 of the lcd, the d4..d7 can be left unconnected.
Only writes to the lcd are used.
The _r/w pin must be connected to ground.

The size of the lcd must be specified
in characters in the x and y direction.
Common sizes are 16x1, 16x2, 20x2 and 20x4.

The timing is used for the waits as required by the hd44780 datasheet.



---------------------------------


example
*******


bla blas



.. raw:: pdf

    PageBreak oneColumn

******
random
******

implemented in: library/basics/gf-random.hpp



---------------------------------


This is simple 32-bit LCG random function, for demos and games.
The random facilities of the standard library are not used because
they eat up too much RAM. Do NOT use this for crypto work.

The LCG used is the Microsoft Visual/Quick C/C++ variant as explained
on https://en.wikipedia.org/wiki/Linear_congruential_generator, but
using bits 8..23 rather than 16..30.



---------------------------------

[>random16<]
:: 

  uint16_t random16(){ ... }
  

The random16() function returns a 16-bit non-negative pseudo-random number.



---------------------------------

[>random32<]
:: 

  uint32_t random32(){ ... }
  

The random32() function returns a 32-bit non-negative pseudo-random number.



---------------------------------

[>random_in_range<]
:: 

  template< typename int_type >
  int_type random_in_range(
     by_const< int_type >first,
     by_const< int_type > last
  ){ ... }
  

The random_in_range() function returns a non-negative pseudo-random number
in the range [ first .. last ].
This number is calculated from a number generated by random32
by modulo arithmetic.
This is simple and fast, but the distribution is not ideal:
the higher values in the range will be somewhat underrepresented.
When the width of the range is much smaller than 2^32 this
effect will be small.



---------------------------------

[>random_seed<]
:: 

  void random_seed( by_const< uint32_t > x ){ ... }
  

The random_seed() function sets the start for the value
returned by subsequent random calls.
It can be used to re-start a random sequence, or (when you have
a truely random source) to start a truely random random sequence.

[>GODAFOSS_INLINE<]


.. raw:: pdf

    PageBreak oneColumn

*****************************
function and class attributes
*****************************

implemented in: library/basics/gf-attributes.hpp



---------------------------------


:: 

  #define GODAFOSS_INLINE  ...
  

GODAFOSS_INLINE forces a function to be inline.
It is used when the function body is very simple, for instance when
it calls only one deeper function.
This serves (only) to reduce code size and execution time.



---------------------------------

[>GODAFOSS_NO_INLINE<]
:: 

  #define GODAFOSS_NO_INLINE  ...
  

GODAFOSS_NO_INLINE forces a function to be not inline.
This is used to preserve low-level properties of a function,
like the number of cylces taken by the function preable and postamble.
This can be important to get predictable timing.



---------------------------------

[>GODAFOSS_NO_RETURN<]
:: 

  #define GODAFOSS_NO_RETURN  ...
  

GODAFOSS_NORETURN indicates that a function will not return.
It is used for functions that contain a never-ending loop.
This can reduce code size.



---------------------------------

[>GODAFOSS_IN_RAM<]
:: 

  #define GODAFOSS_IN_RAM  ...
  

GODAFOSS_IN_RAM places the function body in RAM (instead of FLASH).
On some targets, this is necesarry to get predicatable timing,
or faster execution.



---------------------------------

[>GODAFOSS_RUN_ONCE<]
:: 

  #define GODAFOSS_RUN_ONCE               ...
  

GODAFOSS_RUN_ONCE causes the remainder of the function (the part after
the macro) to be executed only once.



---------------------------------

[>not_constructible<]
:: 

  struct not_constructible { ... };
  

Inheriting from not_constructible makes it impossible to create objects
of that class.



---------------------------------

[>not_copyable<]
:: 

  struct not_copyable { ... };
  

Inheriting from not_copyable makes it impossible to copy an object
of that class.

[>background<]


.. raw:: pdf

    PageBreak oneColumn

*********************
background processing
*********************

implemented in: library/basics/gf-background.hpp



---------------------------------


The background class provides a hook for run-to-completion style
background processing.

:: 

  struct background : public not_copyable {
     // This function will be called to do background work for its object.
     virtual void work() = 0;
  };
  


A class that needs background processing must inherit from background
and implement the work function. This work function will be called
when plain wait functions (the ones that allow background processing)
are called.

When an application contains background work,
all plain wait functions can take longer than the specified time,
up to the run time of the longest runtime of the work() functions.

No background work will be done from wait calls made while
a work() function is running.

For all background jobs: be careful to preserve the object,
or your servicing will end.
This is not UB: the background destructor
removes itself from the list of background jobs.

When the application would terminate (exit from its main()),
background::run() can be called instead, which will serve
the background processing (it will never return).



---------------------------------


example
*******

:: 

  #include "godafoss.hpp"
  namespace gf  = godafoss;
  using target  = gf::target<>;
  using timing  = target::timing;
  
  struct background_work: gf::background {
  
     timing::ticks_type last = timing::now_ms();
  
     void work() override {
        auto now = timing::now_ms();
        if( now > last + 1'000 ){
           gf::cout << "Another second has passed\n";
        }
     }
  
  };
  
  int main(){
  
     {
        background_work annnoying;
        for( int i = 0; i < 10; ++i ){
           timing::wait_ms( 2'800 );
           gf::cout << "[" << i << "] 2.8 seconds passed\n"
        }
        // annnoying is destructed here, so it will finally shut up
     }
  
     for( int i = 0; i < 10; ++i ){
        tinming::wait_ms( 2'100 );
        gf::cout << "[" << i << "] 2.1 seconds passed\n"
     }
  
  };
  


[>uint_bits<]


.. raw:: pdf

    PageBreak oneColumn

********************************
ints specified by number of bits
********************************

implemented in: library/basics/gf-ints.hpp



---------------------------------


:: 

  template< uint64_t n > struct uint_bits {
     typedef typename ...
        fast;
     typedef typename ...
        least;
  };
  


uint_bits< N >::fast is the smallest 'fast'
unsigned integer type that stores (at least) N bits.

uint_bits< N >::least is the smallest (but not necesarrily fast)
unsigned integer type that stores (at least) N bits.

As both are unsigned they should be used for bit patterns, not for amounts.

Note that both can be larger than requested, so they should not be used
for modulo arithmetic (at least not without masking out excess bits).

Use uint_bits< N >::fast for variables and parameters,
use uint_bits< N >::least for arrays.



---------------------------------


example
*******


bla bla



.. raw:: pdf

    PageBreak oneColumn

****************************
passing a readonly parameter
****************************

implemented in: library/basics/gf-passing.hpp



---------------------------------


:: 

  // use by_const< T > when passing a T
  template< typename T >
  using by_const = ...
  

[>by_const<]

The by_const< type > template is the preferred way to pass a
const value of the type passed_type.
This will be either a plain (by copy) const, or a const reference,
depending (among other things) on the size of the type compared
to a the size of a reference.

:: 

  #include "array"
  #include "godafoss.hpp"
  namespace gf  = godafoss;
  
  void GODAFOSS_NO_INLINE f1(
     gf::by_const< char > p
  ){ (void) p; }
  
  void GODAFOSS_NO_INLINE f2(
     gf::by_const< std::array< int, 100 > > p
  ){ (void) p; }
  
  int main(){
  
     // should probably be passed by value (copy)
     f1( 'x' );
  
     // should be probably be passed by reference
     f2( std::array< int, 100 >{ 0 } );
  
  };
  


[>xy<]


.. raw:: pdf

    PageBreak oneColumn

****
xy<>
****

implemented in: library/adts/gf-xy.hpp



---------------------------------


:: 

  template<
     typename xy_value_type = int64_t,
     xy_value_type zero = 0 >
  struct xy final {
     using value_t = xy_value_type;
     value_t x, y; ... };
  


The xy< T > ADT class template is a pair of two T values named x and y.
It is used for distances in an xy plane, like on a window or terminal.
The xy< torsor< T > > is used to identify a location on an xy plane.

The ADT supports
- addition



---------------------------------


methods
*******


:: 

     constexpr xy():x{ zero }, y{ zero }{}
  


The default constructor intializes a and y to the zero value.

:: 

     constexpr xy( value_t x, value_t y ): x{ x }, y{ y }{}
  


The two-value constructor initializes the x and y from the supplied values.

:: 

     template< typename X >
     constexpr xy( const xy< X > & rhs ): x( rhs.x ), y( rhs.y ) {}
  


An xy object can be constructed from an xy with the same or
a different value type.



.. raw:: pdf

    PageBreak oneColumn

******
string
******

implemented in: library/adts/gf-string.hpp



---------------------------------

[>string<]
:: 

  template< std::size_t _maximum_length >
  struct string { ... }
  


This is a fixed-maximum-size string.
It offers an alternative to std::string and raw 0-terminated char arrays.
It doesn't use the heap, and doesn't cause Undefined Behaviour with
buffer overflows or out-of-bounds indexes.

The functions that extend the string by appending characters do so
up to the maximum length of the string. Appending characters beyond
this maximum length has no effect: the excess characters are ignored.

The functions that access a character at an index (a position within
the stored string) do so only when the index is valid. When the index
is invalid, an undefined character (or a reference to an undefined
character) is returned.



---------------------------------


attributes
**********


:: 

     using size_t = std::size_t;
     static constexpr size_t maximum_length = _maximum_length;
  

The maxmimum_length is the maxiumum number of character that can be
stored by the string.



---------------------------------

:: 

     constexpr size_t length() const { ... }
  

The member function length() returns number of characters
that are currently stored.



---------------------------------

:: 

     constexpr bool valid_index( const size_t n ) const { ... }
  

The member function valid_index( n ) returns whether n is a valid index
into the curretly stored string of characters.



---------------------------------

:: 

     string & append( char c ){ ... }
     string & operator+=( char c ){ ... }
     string & operator<<( char c ){ ... }
  

The append function, the operator+= and the operator<< all append a
single character to the string. If the string is already at its maximum
length the character is ignored.



.. raw:: pdf

    PageBreak oneColumn

*************
date and time
*************

implemented in: library/adts/gf-date-time.hpp



---------------------------------

[>date_and_time<]
:: 

  struct date_and_time {
     uint8_t seconds, minutes, hours;
     uint8_t day, month, year;
     uint8_t weekday;
  };
  


This is a datatype for representing a date-and-time,
intended for use with timekeeping chips or peripherals.



---------------------------------


attributes
**********


The atributes of data_and_time are:
   - seconds (0-59), minutes (0-59), hours (0-23)
   - day (1..28/29/30/31), month (1-12), year (0-99)
   - weekday (1..7)

When the weekday is not known (some chips don't have it), it is set to 0.



---------------------------------


non-member functions
********************


:: 

  stream & operator<<( stream & lhs, by_const< date_and_time > dt ){ ... }
  


The operator<< prints a data_and_time in the format YY-MM-DD HH:MM.SS dW.

[>no_inline<]


.. raw:: pdf

    PageBreak oneColumn

*********
no_inline
*********

implemented in: library/item/gf-item-no-inline.hpp



---------------------------------


The no_inline<> item decorator creates an item for which all functions
are not inline.

This can be used as the outermost decorator around an item constructed
from a chain of inheritances, in which the chain of function calls
is all marked GODAFOSS_INLINE.

:: 

  template< item T >
  using no_inline = ... ;
  


[>cto<]


.. raw:: pdf

    PageBreak oneColumn

***
cto
***

implemented in: library/item/gf-item.hpp



---------------------------------


A cto is a Compile Time Object: it has the role of an object,
but it is 'created' at compile time.
It is implemented as a struct
that has only static functions and static attributes.

A cto always exists: it is just 'waiting' to be used.
The features of a cto that are not used will be elimiated by the linker,
Hence the mere presence of a cto in the source doen not increase
the size of the executable image.

A cto, being a type, is never instantiated.
Instead, each cto provides an init() function.
Before any of its functions or attributes are used at run-time,
a cto must be initialized by calling its init() function.
Failing to do so can cause unpredictable results.

As a cto has only static functions and attributes
it can be used directly, or the cto can be passed as
a template parameter.

For cto, and for each more specific cto, a concept exists
(with the name of the cto), and a root struct from which all
such cto's are derived (with _root appended to the name of the cto).

The concept checks both for a specific marker, which serves
no other purpose than to identify the specific cto, and for the
features that the cto isw obliged to offer.
The concept is used to constrain templates that want to accept
only a cto that implements a specific set of features.

The root can be a plain struct, but it is often a template.
For more complex cto's the CRTP pattern is used so the root can
provide both base properties and enrichment based on the provided
implementation.

:: 

  template< typename T >
  concept cto = requires {
     T::_cto_marker;
     { T::init() } -> std::same_as< void >;
  };
  


A cto has a static init() function that can be called without arguments.

:: 

  struct cto_root {
     static const bool _cto_marker = true;
  };
  


The struct cto_root is the root type of all cto's:
all cto's inherit (in most cases indirectly) from this struct.


[>item<]


.. raw:: pdf

    PageBreak oneColumn

****
item
****

implemented in: library/item/gf-item.hpp



---------------------------------


An item is the basic cto from which most other cto's are derived.

A summary of terms:
   - cto: a compile-time (static) object
   - item: holds some data elements(s))
   - box: item that always holds one element of the data
   - pipe: item that holds a sequence of data elements
   - input: item that supports read()
   - output: item that supports write()
   - input_output: both input and output
   - duplex: both input and output at the same time
   - simplex: both input and output, but not at the same time

:: 

  template< typename T >
  concept item = requires {
     cto< T >;
     T::_item_marker;
  };
  


An item is a cto that holds one or more data elements of a specific type.

:: 

  template< typename T >
  struct item_root : cto_root {
     static const bool _item_marker = true;
     using value_type = T;
  };
  


All items inherit (in most cases indirectly) from the struct item_root.

[>box<]
[>pipe<]


.. raw:: pdf

    PageBreak oneColumn

*********
box, pipe
*********

implemented in: library/item/gf-item.hpp



---------------------------------


A box and a pipe are two kinds of items.
The difference is their semantics: a box behaves like a variable
that holds a single value,
a pipe behaves like a sequence of values.



---------------------------------


box
***


An box is an item that has or contains (at any point in time) a single value.
An box has value semantics:
when you read from a box twice in rapid succession,
you will get the same value.
Writing to an item overwrites its old value in the box.

:: 

  template< typename T >
  concept box = requires {
     item< T >;
     T::_box_marker;
  };
  

:: 

  template< typename T >
  struct box_root :
     item_root< T >
  {
     static const bool _box_marker = true;
  };
  




---------------------------------


pipe
****


A pipe is an item that holds a sequence of values.
A write to a pipe adds a new value the sequence.
Hence all writes to a stream matter, including
repeated writes of the same value.
Reading from a pipe is destructive: it consumes the value that was
read from the sequence.
Writing to a pipe adds a value to the sequnce.

:: 

  template< typename T >
  concept pipe = requires {
     item< T >;
     T::_pipe_marker;
  };
  

:: 

  template< typename T >
  struct pipe_root :
     item_root< T >
  {
     static const bool _pipe_marker = true;
  };
  


[>input<]
[>output<]
[>input_output<]
[>duplex<]
[>simplex<]


.. raw:: pdf

    PageBreak oneColumn

*************
input, output
*************

implemented in: library/item/gf-item.hpp



---------------------------------


An item can be an input (from which you can read) and/or an output
(to which you can write).

An input or output item can be buffered.
For an output, this means that the effect of write operations
can be postponed until the next flush call.
For an input, this means that a read operation reflects
the situation immediately before that last refresh call, or later.
For immediate effect on a buffered item, a read must be preceded
by a refresh, and a write must be followed by a flush.

The direct<> decorator creates an item for which the
read() and write() operations have direct effect.

An item can be an input, an output, or both.
When it is an input you can read from it,
when it is an output you can write to it.
(In theory an item could be neither,
but that would not be very useful.)

When an item is both input and output it can be simplex
(sometimes call half-duplex) or duplex.
A duplex box can, at any time, be both read and written.



---------------------------------


input
*****

:: 

  template< typename T >
  concept input = requires {
     item< T >;
     T::_input_marker;
     { T::refresh() }  -> std::same_as< void >;
     { T::read() }     -> std::same_as< typename T::value_type >;
  };
  

:: 

  template< typename T >
  struct input_root :
     item_root< T >
  {
     static const bool _input_marker = true;
  };
  


A input is an item that provides a read function that returns
a value of the value_type of the item.



---------------------------------


output
******

:: 

  template< typename T >
  concept output = requires (
     typename T::value_type v
  ){
     item< T >;
     T::_output_marker;
     { T::write( v ) }  -> std::same_as< void >;
  

:: 

  template< typename T >
  struct output_root :
     item_root< T >
  {
     static const bool _output_marker = true;
  };
  


An output is an item that provides a write function that accepts
a value of the value_type of the item.



---------------------------------


input_output
************

:: 

  template< typename T >
  concept input_output = requires {
     input< T >;
     output< T >;
  };
  

:: 

  template< typename T >
  struct input_output_root :
     input_root< T >,
     output_root< T >
  {};
  


An input_output is an item that is both an input and an output.



---------------------------------


direction
*********


A duplex item is an input_output that can function both as
an input and as an output at the same time.

:: 

  template< typename T >
  concept duplex = requires {
     input_output< T >;
     T::_duplex_marker;
  };
  

:: 

  template< typename T >
  struct duplex_root :
     input_output_root< T >
  {
     static const bool _duplex_marker = true;
  };
  


A simplex item is an input_output that has a current direction,
which can be input or output.

:: 

  template< typename T >
  concept simplex = requires {
     input_output< T >;
     T::_simplex_marker;
     { T::direction_set_input() }   -> std::same_as< void >;
     { T::direction_set_output() }  -> std::same_as< void >;
     { T::direction_flush() }       -> std::same_as< void >;
  };
  

:: 

  template< typename T >
  struct simplex_root :
     input_output_root< T >
  {
     static const bool _simplex_marker = true;
  };
  


The direction of a simplex item can be changed
with a direction_set_input or direction_set_output call.
For a successful read, the direction of a simplex box must be input.
For a successful write, the direction of a simplex box must be output.
Otherwise a write can have no effect at all, or have a delayed effect,
and a read returns an unspecified value, and for a stream it can either
consume the value or not.

The effect of calling a direction_set... function can be delayed
up to the next direction_flush() call.
Like for read() and write(), direct<> can be used
to get an immediate effect.

[>invert<]


.. raw:: pdf

    PageBreak oneColumn

******
invert
******

implemented in: library/item/gf-item-invert.hpp



---------------------------------


The invert<> decorator inverts the value written to or read from an item.

:: 

  // invert is supported for an item that has an invert function
  template< typename T >
  concept can_invert = requires (
     typename T::value_type v
  ) {
     item< T >;
     { T::invert( v ) } -> std::same_as< typename T::value_type >;
  };
  

:: 

  template< can_invert T >
  struct invert< T > ... ;
  




.. raw:: pdf

    PageBreak oneColumn

*************
item adapters
*************

implemented in: library/item/gf-item-adapters.hpp



---------------------------------


These adapter adapts a item to be (only) an input item,
(only) an output item,
or an input_output item (if such adaption is possible).

[>item_input<]


---------------------------------


item_input
**********


:: 

  template< typename T >
  concept can_input =
        input< T >
     || input_output< T >;
  

:: 

  template< can_input T >
  struct item_input ... ;
  


The item_input<> decorator decorates an item to be an input item,
which is possible if the item satisfies the can_input concept.

:: 

  template< typename T >
  concept can_output =
        output< T >
     || input_output< T >;
  

:: 

  template< can_output T >
  struct item_output ... ;
  


The item_output<> decorator decorates an item to be an output item,
which is possible if the item satisfies the can_output concept.

:: 

  template< typename T >
  concept can_input_output =
       input_output< T >;
  
  

:: 

  template< input_output T >
  struct item_input_output ... ;
  


The item_input_output<> decorator decorates
an item to be an input_output item,
which is possible if the item satisfies the can_input_output concept.

[>direct<]


.. raw:: pdf

    PageBreak oneColumn

******
direct
******

implemented in: library/item/gf-item-direct.hpp



---------------------------------


The direct<> decorator accepts an item and decorates it by
inserting the appropriate refresh or flush
before or after each read, write, or direction change operation,
and replacing the refresh and flush operations by empty functions.

The effect is that such a decorated item can be used without
refresh or flush calls.

:: 

  template< typename T >
  concept can_direct = requires {
     item< T >;
  };
  

:: 

  template< typename T >
     requires can_direct< T >
  struct direct< T > : ... ;
  




.. raw:: pdf

    PageBreak oneColumn

*********
inherit_*
*********

implemented in: library/item/gf-item-inherit.hpp



---------------------------------


Adapters for selectively inheriting only the init,
read, write, or direction functions of a item.
This is used or instance in the item_input<> adapter, to
'pass' only the input functionality.

[>inherit_init<]


---------------------------------


inherit_init
************

:: 

  template< typename T >
  struct inherit_init = ... ;
  


The inherit_init decorator inherits only the init() function of
the decorated item.

[>inherit_read<]


---------------------------------


inherit_read
************

:: 

  template< typename T >
  struct inherit_read = ... ;
  


The inherit_read decorator inherits only the refresh() and read()
functions of the decorated item.

[>inherit_write<]


---------------------------------


inherit_write
*************

:: 

  template< typename T >
  struct inherit_write = ... ;
  


The inherit_read decorator inherits only the write() and flush()
functions of the decorated item.

[>inherit_direction<]


---------------------------------


inherit_direction
*****************

:: 

  template< typename T >
  struct inherit_direction = ... ;
  


The inherit_read decorator inherits only the
direction_set_input(), direction_set_output() and
direction_flush()
functions of the decorated item.

[>buffered<]


.. raw:: pdf

    PageBreak oneColumn

********
buffered
********

implemented in: library/item/gf-item-buffered.hpp



---------------------------------


The buffered<> decorator buffers read, write or direction operations,
necessitating appropriate refresh or flush calls.

:: 

  template< typename T >
  concept can_buffered = requires {
     item< T >;
  };
  

:: 

  template< can_buffered T >
  struct buffered
  :
     _buffered_read< ... ;
  


