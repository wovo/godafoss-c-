ubuntu notes
- sudo apt install git, codelite, python-is-python3, 
   libsfml-dev, gcc-10, g++-10, gnome-terminal
- clone godafoss, bpmtk, catchorg/Catch2
- codelite startup
-> make codelite startup script
- codelite start de exe niet goed
- use 'ubuntu software' to install notepad++



- xy in hd44780 should be smaller
- component should be torsor< int > ???
- how to access low-level of a torsor?
- copy torsor back
- specify location of an sfml window??
- item -> value, single, atom
- ICE from windows

files to check
==============
   + core/gf-basics.hpp
   + core/gf-ints.hpp
   core/gf-passing.hpp
   core/gf-output-stream.hpp
   core/gf-xy.hpp

   + box/gf-box.hpp
   + box/gf-box-inherit.hpp
   + box/gf-box-no-inline.hpp
   + box/gf-box-invert.hpp
   + box/gf-box-direct.hpp
   + box/gf-box-buffered.hpp
   + box/gf-box-adapters.hpp

   pins/gf-pin.hpp
   pins/gf-pin-adapters.hpp
   pins/gf-pin-dummies.hpp
   pins/gf-pin-out-from-pins.hpp
   pins/gf-pin-demos.hpp

   core/gf-analog.hpp

   ports/gf-port.hpp
   ports/gf-port-adapters.hpp
   ports/gf-port-dummies.hpp
   ports/gf-port-from-pins.hpp
   ports/gf-port-demos.hpp

   timing/gf-timing-wait.hpp
   timing/gf-timing-clock.hpp
   timing/gf-slow-down.hpp

   core/gf-spi.hpp
   core/gf-i2c.hpp

   char-io/gf-uart.hpp
   char-io/gf-ostream.hpp
   char-io/gf-ostream-object.hpp
   char-io/gf-terminal.hpp
   char-io/gf-terminal-demos.hpp

   graphics/gf-color.hpp
//   graphics/gf-window.hpp
//   graphics/gf-drawables.hpp
//   graphics/gf-window-demos.hpp

   chips/gf-servo.hpp
   chips/gf-hd44780.hpp
   chips/gf-hc595.hpp
   chips/gf-pcf8574.hpp
//   chips/gf-pcf8591.hpp
//   chips/gf-ssd1306.hpp
   chips/gf-nrf24l01.hpp

C++20 (GCC 10) required

refresh error flags list

pullup from adapters => pins, or even to core (shared by ports)?
should pullup also be buffered??

should pullup be propagated by port?

// ?? why is this needed?
template< can_output T > struct box_out; (box adapters)

term: interface-oriented (concept-oriented)

file naming: gf-core-*; maybe put everything back in one directory?

should the HAL pop the warning settings??

Get back to your code after some time. 
Add comments to explain it in simple terms.
Make the identifiers match those terms.
Remove the comments.
box_init_filter<> => box_only_init<>
It IS a filter, that is how it works, but that is the wrong name.
What it DOES for the using code is passing only a specific part.
When in doubt about naming: forget the implementation, read where it is used.
if you need a comment THERE, the name is wrong.

thing-name variations are needed for the:
- is_thing             (user) concept
- be_thing_root        (lib/HAL writer) root class 
- be_thing             (HAL writer) creator that makes the thing from a HAL-provided base
- is_thing_root thing  (HAL writer) concept for that HAL-provided base
- make_thing?          (user) decorator/adapter that makes the thing from a related thing or set of things
- can_thing?           (all) can be made into a thing

color : concept
color : default color? or is that rgb24? rgb32?

When in doubt how to implement an ADT or driver interface:
- write an interface that specifies as little as possible
- write an implementation
- write the library to the interface, not the implementation

tag: is_thing_tag ? now only is_thing

check die lezing @ code dive voor naamgeving?

the name filter is exactly the wronmg way round??
box buffered requires default constructor & assignment
=> put that as requirement in box?

add as-value, subrange


loop< 8 >([]{   
   
})

add hwlib::work to godafoss? defeats the static call-tree....
I must up-propagate the work via the init

making sure all inits are called is error-prone, 
but it vcan be *checked* by an external tool 
=> the tool's output is not part of the build
(contrary to stack size calculation)


template< can_gpo _pin >
struct {
   using pin = make_gpo< _pin >;
   
   using init = inits< pin >;
   static void init(){
      pin.write( 0 );
   }
   
   static void work(){
      if ...
	  if ...
   }
   
can a lambda capture private statics???   
non-capturing lambda decays to a function pointer
-> three types: init, work, main

   using minions = minion_list<
      pin,                           // has a minions
	  init< []{ pin.write( 0 ); }>,  // a function to be called once
	  timing::main< loop >           // a thread body
	                                 // a one-shot worker
									 // etc: other workers, defined by the scheduler
   >;	  
   
   static void loop(){
      for(;;){
	     timing::ms< 500 >::wait();
		 pin.write( 1 );
      }
   }
   
I can't write the main the nornmal way, with a loop => doesn't serve the threads or one-shots

can I find out whether sometghing needs a thread, or can do with a one-shot?
can decide on a per-cto base, or from tool analysis....
   
main(){
   using led = target::d2;
   using minions = blink< led, timing::ms< 100 >>;
   minions::run();
}   

Can I restrict the functions used in a main or init or repeated?
repeated should not use wait (only wait_busy when realy needed) 
=> can do that with tooling...
   
main(){
   using led = target::d2;
   timing::main< []{
      for(;;){
	     timing::ms< 500 >::wait();
		 ...
   } >::run();
}   

TOOLING
preferred way: use tooling to check conformance
treat this like malformed-NDR, but the req. are outside the language

Is the call the run-to-completion from the waits possible (CRTP?)
   