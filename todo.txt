https://github.com/MoebiusTech
https://github.com/shihaipeng03/MiniTelegraph.git
https://www.dansaks.com/articles.shtml
https://github.com/Picovoice
https://jsandler18.github.io/tutorial/locks.html
https://www.reddit.com/r/embedded/comments/lscmen/endtoend_voice_recognition_on_microcontrollers/
https://adspthepodcast.com/2021/03/05/Episode-15.html
https://www.youtube.com/watch?v=4qBKOAv0sBI
https://dl.acm.org/journal/toplas

https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-088478-0
http://craftinginterpreters.com
https://travisdowns.github.io/blog/2020/07/06/concurrency-costs.html
https://ngathanasiou.wordpress.com/2020/07/09/avoiding-compile-time-recursion/
https://pcbshopper.com
https://hackaday.io/project/25596/gallery#f3bbf335d4fabe866589dea38a230367
http://www.righto.com/2017/03/inside-vintage-74181-alu-chip-how-it.html
https://hackaday.com/2019/10/16/the-smallest-homebrewed-ttl-cpu-in-the-world/
https://wiki.keyestudio.com/KS0474_Keyestudio_GAMEPI_DIY_Game_Console_learning_Kit_for_Arduino
https://arduboy.com
https://community.arduboy.com/t/welcome-to-the-arduboy-community/8/15
https://community.arduboy.com/t/production-arduboy-schematic/702/11
https://github.com/pellepl/spiffs\
https://github.com/cpetrich/counterfeit_DS18B20/
https://github.com/R2D2-2019/display
https://github.com/R2D2-2019/I2C_library
https://lvgl.io
https://quick-bench.com/q/zqrtwmHCZTTbbj0WQBWSKeDJm5U
https://www.youtube.com/watch?v=pd9AVmcRc6U
https://drive.google.com/drive/folders/19pG3goVq1-Tf5rUn8wSy5ltm_D6MKXWM
https://github.com/MoebiusTech/Arduino-Mini-ladar/blob/master/Mini%20Radar%20insllation%20.pdf
https://twitter.com/i/topics/news/e-316591003?cn=ZmxleGlibGVfcmVjcw%3D%3D&refsrc=email
https://leanpub.com/c20
https://docs.modm.io
https://mightydevices.com/index.php/2019/09/building-bare-metal-stm32l4-firmware-using-clang-llvm/
http://www.nuonsoft.com/blog/2020/12/26/book-beginning-c20/
https://github.com/kiwih/rp2040-vscode-picoprobe-project-c-template
https://www.toptal.com/c-plus-plus/interview-questions
https://www.reddit.com/r/embedded/comments/ll4vvf/building_an_operating_system_for_the_raspberry_pi/
https://www.reddit.com/r/cpp/comments/lp40ag/c20_gcc_trunk_getting_constexpr_usable_caller/

https://kevinlynagh.com/rust-zig/
https://lupyuen.github.io/articles/book
https://pine64.com/product/pinetime-dev-kit/?v=0446c16e2e66
https://www.nirsoft.net/utils/run_as_date.html
https://en.wikipedia.org/wiki/Component-based_software_engineering

https://github.com/dwelch67/raspberrypi-pico/tree/master/blinker00
https://github.com/OscarSaharoy/femtoscope
https://libcinder.org
https://github.com/rsta2/circle
https://github.com/RIOT-OS/RIOT
https://en.wikipedia.org/wiki/Rr_(debugging)
https://devblogs.microsoft.com/oldnewthing/20140627-00/?p=633
           
https://barrgroup.com/Embedded-Systems/Books/Embedded-C-Coding-Standard
anki robot companion
Arduino powered graffiti maker bike. https://www.instructables.com/Bikelangelo-the-Graffiti-Maker-Bike/

https://blog.thea.codes

https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Common-Function-Attributes.html#index-flatten-function-attribute
https://www.reddit.com/r/embedded/comments/kxvzag/most_common_naming_convention_in_embedded_systems/

https://www.reddit.com/r/embedded/comments/l4bxnl/opensource_file_system/

GUIs:
https://www.reddit.com/r/embedded/comments/l3nj3h/lameui_a_ui_library_for_mcus_i_have_been_making/
https://github.com/lvgl/lvgl

https://pastebin.com/D2ThwPQQ
https://www.cnx-software.com/2021/01/27/a-closer-look-at-raspberry-pi-rp2040-programmable-ios-pio/
                                                                   
micro:bit
https://github.com/dwelch67/microbit
https://github.com/bbcmicrobit/hardware
https://tech.microbit.org/hardware/
https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.3.pdf
https://www.st.com/en/mems-and-sensors/lsm303agr.html

C++ tutorials:
https://www.youtube.com/watch?v=_bYFu9mBnr4
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0843r3.html
https://quuxplusone.github.io/blog/2018/06/18/inplace-vs-fixed-capacity/

https://github.com/lvgl/lvgl

robots
https://create.arduino.cc/projecthub/slantconcepts/buddy-the-3d-printed-arduino-social-robot-ec3dca
https://www.gambody.com/blog/3d-printed-robot/

https://www.youtube.com/watch?v=_bYFu9mBnr4

check https://en.cppreference.com/w/cpp/language/constraints for simpler concepts

https://justanotherelectronicsblog.com/?p=470 - ricv on fpga
https://github.com/Seeed-Studio/ArduinoCore-k210 - riscv with NN
https://maixpy.sipeed.com/en/ - idem with uPython 
https://github.com/kendryte/kendryte-doc-datasheet/blob/master/en/003.md
https://www.seeedstudio.com/blog/2019/09/12/get-started-with-k210-hardware-and-programming-environment/
currently no K210 info to be found?

https://www.raspberrypi.org/blog/raspberry-pi-silicon-pico-now-on-sale/



GBA:
https://github.com/GValiente/butano - check!
https://pineight.com/gba/#gbfs
https://www.gbadev.org/docs.php

Register access:
https://github.com/thanks4opensource/regbits

bleeding edge cross compilers:
(cortex) https://freddiechopin.info/en/download/category/11-bleeding-edge-toolchain
(cortex) https://github.com/xpack-dev-tools/arm-none-eabi-gcc-xpack/releases/                                                                             
(avr8) https://blog.zakkemble.net/avr-gcc-builds/ - no libs
(avr8) https://github.com/CrustyAuklet/avr-libstdcxx/releases/tag/v10.2.0 - includes C++ libs!!
(risc v) https://gnutoolchains.com/risc-v/

meta-case USP ISP : 
- https://irq5.io/2017/07/25/making-usbasp-chinese-clones-usable/
- only a Windows GUI interface
- NOT avrdude compatible

C++ quiz : https://cppquiz.org/quiz/question/186
C++ podcats : https://www.youtube.com/watch?v=XRTm_6SULU0
conference keynotes: https://github.com/codereport/Talks/blob/master/CppConferenceKeynotes.md
https://github.com/bernedom/SI/tree/master/include/SI
https://github.com/trailfrenzy/SIwithET
https://github.com/mithunkamat/ST7567-driver/blob/master/ST7567.c
https://github.com/GValiente/butano
https://artificial-mind.net/blog/2020/10/03/always-false

https://embeddedtronicsblog.wordpress.com/2018/12/29/fake-stm32-blue-pill-boards/


comparable:
- ETL https://github.com/ambroise-leclerc/ETL : only AVR8, only pins, but port optimization

books
https://www.amazon.com/gp/product/1119431107?pf_rd_p=6fc81c8c-2a38-41c6-a68a-f78c79e7253f&pf_rd_r=8N6JEW01G47SE5FZTM9D
- https://www.amazon.com/UNIX-History-Memoir-Brian-Kernighan/dp/1695978552/ref=as_li_ss_tl?ie=UTF8&linkCode=sl1&tag=revragnarok-20&linkId=c77497089c9d796e7c152239c6091859&language=en_US

risc v:
https://github.com/dwelch67/gigadevice_samples/tree/master/Sipeed.Longan.Nano/blinker01++
https://www.dalewheat.com/author/admin/ - serial connection

https://jsandler18.github.io/
https://medium.com/better-programming/modern-languages-suck-ad21cbc8a57c
https://www.learncpp.com/
https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb
                                    

google AI play:
https://aiyprojects.withgoogle.com/

embedded course:
https://course.ece.cmu.edu/~ece642/
https://archive.org/details/@pkoopman

blue pill Logic Analyser:
https://github.com/thanks4opensource/buck50

https://www.reddit.com/r/embedded/comments/kd3gm0/cortexm3_rtos_project_review_or_comment_request/

compile time objects
transient objects - i2c and spi channels
value objects (adts)

onderscheid:
- target chips : mcu-s, chips
- peripheral chips : chips, peripherals
- target boards, boards
- add-on boards (shields, i2c combinations, even single purpose boards) : shields

chips-mcu
chips-peripheral
targets-chip
targets-board
? boards like lcd + buttons

targets, incl 


main is now a bit complicated
use< t >::initialization() - won't work for complicated t, needs to be private?
uart werkt niet meer


riscv
https://github.com/riscv-mcu/GD32VF103_Firmware_Library
https://www.sigmdel.ca/michel/ha/gd32v/longan_nano_01_en.html
                       
                                                                                 

https://freeelectron.ro/installing-st-link-v2-to-flash-stm32-targets-on-linux/
                
            
             
                           

              

https://github.com/Viatorus/compile-time-printer

https://github.com/theacodes/Winterbloom_Castor_and_Pollux/blob/master/firmware/scripts/samd21g18a.ld
               

speerpunten:
- loop p
- ints
- string - plaatje: gitaar
- fraction p
- passing
- random p 0-> random interface?
- background (later?)
- torsor iets met plaats en afstand
- xy p
- color p
- date-and-time kalender + horloge
- template< size_t n > concept range_1_5 = ( ( n >0 ) && ( n < 6 ) );

loop: use smaller integer
make demo for loop test, with measurements


fraction: test, T/V concepts, sink concept

window decorators must use the largest of the colors and xy, not always color<>
harware SPI via de USART

document 'byte source' and byte sink interfaces (iwc, spi, nrf24)
note: arduino due i2c1 has no pull-ups, ic2 on pcb == i2c0
write book for embedded C programmers?

i2c-bus vereenvoudigen
concepts weer invoeren
is_i2c_bus concept uitbreiden

test due i2c1

bb spi opsplitsen ala i2c
bb spi voor aleen output kan sneller (bekijk assembly?)

https://github.com/cpetrich/counterfeit_DS18B20/


timing
clock timing
i1c abstraction
hardware i2c
hardware spi pins
oled spi
sam3x8e short timing klopt niet - 82 niet meegenomen??

i2c fast is now > 400 kHz!, 100kHz is ietsje te snel

due tng - alernate random source
demo N bouncing balls
demo random by snow on the display
ssd1306 half-size displays

simplfy using https://en.cppreference.com/w/cpp/types/is_same
invert a source of fraction (ADC)
ssd1306 spi
i2c channel abstraction
i2c hardware

fraction operator- ??
clock timing service, oled timings
bouncing balls demo
i2c from run-time address (bus scanner)
pin_out from window!
lcd scrolling message demo, take from
oled on lpc1114 past niet in de RAM??
db103 lpc21isp houdt de chip in reset - no serial :( -> bmptk -control

bouncing square: minimum size 1 -> 2x2 pixels!
 init() with value -> all boxes must CRTP
 init_as_input for input-output boxes??
 struct everywhere
 script that makes one giant include file
 i2c::read_transaction + i2c:read_register( reg )
 use std::byte

 test random op een cortex
 - string size should be int with max value

 bmptk modified:
- USB0 for db103
- -control for DB103 terminal command

595 flexible number of pins?
random blocks two-files project!
random is too large for an LPC1114
db103 needs two 595 board and test
db103 ADC not tested -> use PCF8591 PCB
port< > instead of port_out_from<> etc?
gpio direct werkt niet, daarmee verder
decorators have commented out requires clauses
compatible should have
all<> must now be at least two...
pin_out<> == decorator, pin_out_type (_concept) is the concept??
a torsor can be created location_t( x, y ) ??? and it is wrong!
in window-all : xy zonder <> ??
uart has no flush??
lpc1114 uart  doesn't work
lpc1114 only 12 MHz
background gebruikt nu indirection
test non-copyable, not-constructible

ubuntu notes
- sudo apt install git, codelite, python-is-python3,
   libsfml-dev, gcc-10, g++-10, gnome-terminal
- clone godafoss, bpmtk, catchorg/Catch2
- codelite startup
-> make codelite startup script
- codelite start de exe niet goed
- use 'ubuntu software' to install notepad++

- xy in hd44780 should be smaller
- component should be torsor< int > ???
- copy torsor back
- item -> value, single, atom
- ICE from windows
- check windows 'uart'
- passing should take call into account, less efficient & 'x'??
- small-scale test random embedded

files to check

   x t + basics/gf-attributes.hpp
   t + basics/gf-shared-names.hpp - must be removed!
   t + basics/gf-ints.hpp - bigint afsplitsen
   t + basics/gf-passing.hpp
   t + basics/gf-random.hpp
       basics/gf-background.hpp

   adts/gf-output-stream.hpp
   adts/gf-xy.hpp
   adts/gf-color.hpp

   t + box/gf-box.hpp
    + box/gf-box-inherit.hpp
    + box/gf-box-no-inline.hpp
    + box/gf-box-invert.hpp
    + box/gf-box-direct.hpp
    + box/gf-box-buffered.hpp
    + box/gf-box-adapters.hpp

    + pins/gf-pin.hpp
   pins/gf-pin-adapters.hpp
    + pins/gf-pin-dummies.hpp
// pin-testers
   pins/gf-pin-demos.hpp

   core/gf-analog.hpp

   ports/gf-port.hpp
   ports/gf-port-adapters.hpp
   ports/gf-port-dummies.hpp
   ports/gf-port-from-pins.hpp
   ports/gf-port-demos.hpp

   timing/gf-timing-wait.hpp
   timing/gf-timing-clock.hpp
   timing/gf-slow-down.hpp

   core/gf-spi.hpp
   core/gf-i2c.hpp

   ostream/gf-stream
   ...

   char-io/gf-terminal.hpp
   char-io/gf-terminal-demos.hpp

//   graphics/gf-window.hpp
//   graphics/gf-drawables.hpp
//   graphics/gf-window-demos.hpp

   chips/gf-servo.hpp
   chips/gf-hd44780.hpp
   chips/gf-hc595.hpp
   chips/gf-pcf8574.hpp
//   chips/gf-pcf8591.hpp
//   chips/gf-ssd1306.hpp
   chips/gf-nrf24l01.hpp

C++20 (GCC 10) required

refresh error flags list

pullup from adapters => pins, or even to core (shared by ports)?
should pullup also be buffered??

should pullup be propagated by port?

// ?? why is this needed?
template< can_output T > struct box_out; (box adapters)

term: interface-oriented (concept-oriented)

file naming: gf-core-*; maybe put everything back in one directory?

should the HAL pop the warning settings??

Get back to your code after some time.
Add comments to explain it in simple terms.
Make the identifiers match those terms.
Remove the comments.
box_init_filter<> => box_only_init<>
It IS a filter, that is how it works, but that is the wrong name.
What it DOES for the using code is passing only a specific part.
When in doubt about naming: forget the implementation, read where it is used.
if you need a comment THERE, the name is wrong.

thing-name variations are needed for the:
- is_thing             (user) concept
- be_thing_root        (lib/HAL writer) root class
- be_thing             (HAL writer) creator that makes the thing from a HAL-provided base
- is_thing_root thing  (HAL writer) concept for that HAL-provided base
- make_thing?          (user) decorator/adapter that makes the thing from a related thing or set of things
- can_thing?           (all) can be made into a thing

color : concept
color : default color? or is that rgb24? rgb32?

When in doubt how to implement an ADT or driver interface:
- write an interface that specifies as little as possible
- write an implementation
- write the library to the interface, not the implementation

tag: is_thing_tag ? now only is_thing

check die lezing @ code dive voor naamgeving?

the name filter is exactly the wronmg way round??
box buffered requires default constructor & assignment
=> put that as requirement in box?

add as-value, subrange


loop< 8 >([]{

})

add hwlib::work to godafoss? defeats the static call-tree....
I must up-propagate the work via the init

making sure all inits are called is error-prone,
but it vcan be *checked* by an external tool
=> the tool's output is not part of the build
(contrary to stack size calculation)


template< can_gpo _pin >
struct {
   using pin = make_gpo< _pin >;

   using init = inits< pin >;
   static void init(){
      pin.write( 0 );
   }

   static void work(){
      if ...
      if ...
   }

can a lambda capture private statics???
non-capturing lambda decays to a function pointer
-> three types: init, work, main

   using minions = minion_list<
      pin,                           // has a minions
      init< []{ pin.write( 0 ); }>,  // a function to be called once
      timing::main< loop >           // a thread body
                                     // a one-shot worker
                                     // etc: other workers, defined by the scheduler
   >;

   static void loop(){
      for(;;){
         timing::ms< 500 >::wait();
         pin.write( 1 );
      }
   }

I can't write the main the nornmal way, with a loop => doesn't serve the threads or one-shots

can I find out whether sometghing needs a thread, or can do with a one-shot?
can decide on a per-cto base, or from tool analysis....

main(){
   using led = target::d2;
   using minions = blink< led, timing::ms< 100 >>;
   minions::run();
}

Can I restrict the functions used in a main or init or repeated?
repeated should not use wait (only wait_busy when realy needed)
=> can do that with tooling...

main(){
   using led = target::d2;
   timing::main< []{
      for(;;){
         timing::ms< 500 >::wait();
         ...
   } >::run();
}

TOOLING
preferred way: use tooling to check conformance
treat this like malformed-NDR, but the req. are outside the language

Is the call the run-to-completion from the waits possible (CRTP?)

todo
- check void return types (core & box)
- check xy iterator
- pullup/down should survive pin adapters
- pullup<> decorator
- pin_in from adc for my-first-devboard
- mfd: walk / select color, speed
- mfd: board test
- mfd: dimming demo
- can_pin_out etc. don't work?? in pin adapters
- 8574 + LCD
- mirror for ports, demo
- servo demo with NRF
- cout has no << flush??
- range adt
- hwlib i2c aanpasen, overnemen
-0 check https://github.com/olikraus/u8g2/wiki

- wouter / hbo-ict
- embedded
- my embedded niche
- C/C++ styles
- features to avoid
- low-hanging fruit
- dependency injection, #define/names, identifiers/parameters, objects/contsructors, classes/templates
- concepts
- test syntax versus test intended semantics
- abstractions: pins, ports, timing
- additive filters / limitative filters
- performance aspects: injection styles, buffering
- I2C & SPI: channel/transaction
- timing abstraction, small delays
- remaining issues: C++ user-defined template parameters
- how to print without std::cout
- problem with CRTP
- remaining issues: users, abstractions, timing, testing, documentation (doxygen doesn't work)

targets
- cortex M
- ESP32
- RISC V
- AVR8
- Raspberry Pi https://github.com/rsta2/circle (C: https://github.com/bztsrc/raspi3-tutorial)

have only one type of timing?
target provides the run, hence the target is always initialized? 0- fails for configurable target - no

development board 2.0
blue pill
switches
4x4 keypad / 5x4?
LCD / oled
beeper
2 x AA battery
IR RX, TX
options
NRF905/2401
MPU6050
SRF04
ESP8266
memory card?? eeprom chip
LCD met touch
smartpixel  3/4 pin output
LDR
DHT11
dallas (5V?)
I2C
2 x joystick

GCC 10 on Arch

download https://developer.arm.com/-/media/Files/downloads/gnu-rm/9-2020q2/gcc-arm-none-eabi-9-2020-q2-update-src.tar.bz2?revision=e2232c7c-4893-46b6-b791-356bdc29fd7f&la=en&hash=8E864863FA6E16582633DEABE590A7C010C8F750
from https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads
unpack it to a build directory
there: git clone git://gcc.gnu.org/git/gcc.git

github.com/MikeLankamp/fpm


template< can_pin _a, timing t >
struct srf04 {
   using a = pin_out< _a >;
   static void init(
      do something
   }
   using resources = use< a, t >;

}

run< blink< target::p1, target::timing > >()

task has priority, stack size (for now)



struct resource_sentinel {
   using tasks = task_sentinel;
   using background = background_sentinel;
   using inits = init_sentinel;
};


template< can_pin_out _pin, can_static_duration _pause >
struct blink {

   using pin = direct< pin_out_from< _pin >>;
   using pause = static_duration< _pause >;

   using resources = resources< pin, pause >;

   static void GODAFOSS_NO_RETURN run(){
      for(;;){
         pin::write( 1 );
         pause::wait();
         pin::write( 0 );
         pause::wait();
      }
   }
};

template< application >
struct run {
   static void GODAFOSS_NO_RETURN run(){
      - call all inits
      - start threading
      application::run();
   }
};

int main(){
   <hoe vind je de naam van wat er gerunt moet worden?
}

- je kan twee apps mergen, dan worden ze tasks
