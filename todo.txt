oled on lpc1114 past niet in de RAM??
db103 lpc21isp houdt de chip in reset - no serial :( -> bmptk -control
random lines werkt niet - ligt het aan de demo??

bouncing square: minimum size 1 -> 2x2 pixels!
 init() with value -> all boxes must CRTP
 init_as_input for input-output boxes??
 struct everywhere
 script that makes one giant include file
 i2c::read_transaction + i2c:read_register( reg )
 use std::byte

 test random op een cortex
 - string size should be int with max value

 bmptk modified:
- USB0 for db103
- -control for DB103 terminal command

595 flexible number of pins?
random blocks two-files project!
random is too large for an LPC1114
db103 needs two 595 board and test
db103 ADC not tested
port< > instead of port_out_from<> etc?
gpio direct werkt niet, daarmee verder
decorators have commented out requires clauses
compatible should have
all<> must now be at least two...
pin_out<> == decorator, pin_out_type (_concept) is the concept??
a torsor can be created location_t( x, y ) ??? and it is wrong!
in window-all : xy zonder <> ??
uart has no flush??
lpc1114 uart  doesn't work
lpc1114 only 12 MHz
background gebruikt nu indirection
test non-copyable, not-constructible

- where is my PCF8574A demo board??
- add NO_TERMINAL option to bmptk

shared names should *also* have a specific name for debugging

ubuntu notes
- sudo apt install git, codelite, python-is-python3,
   libsfml-dev, gcc-10, g++-10, gnome-terminal
- clone godafoss, bpmtk, catchorg/Catch2
- codelite startup
-> make codelite startup script
- codelite start de exe niet goed
- use 'ubuntu software' to install notepad++

- xy in hd44780 should be smaller
- component should be torsor< int > ???
- copy torsor back
- item -> value, single, atom
- ICE from windows
- check windows 'uart'
- passing should take call into account, less efficient & 'x'??
- small-scale test random embedded

files to check

   t + basics/gf-attributes.hpp
   t + basics/gf-shared-names.hpp
   t + basics/gf-ints.hpp
   t + basics/gf-passing.hpp
   t + basics/gf-random.hpp
       basics/gf-background.hpp

   adts/gf-output-stream.hpp
   adts/gf-xy.hpp
   adts/gf-color.hpp

   t + box/gf-box.hpp
    + box/gf-box-inherit.hpp
    + box/gf-box-no-inline.hpp
    + box/gf-box-invert.hpp
    + box/gf-box-direct.hpp
    + box/gf-box-buffered.hpp
    + box/gf-box-adapters.hpp

    + pins/gf-pin.hpp
   pins/gf-pin-adapters.hpp
    + pins/gf-pin-dummies.hpp
// pin-testers
   pins/gf-pin-demos.hpp

   core/gf-analog.hpp

   ports/gf-port.hpp
   ports/gf-port-adapters.hpp
   ports/gf-port-dummies.hpp
   ports/gf-port-from-pins.hpp
   ports/gf-port-demos.hpp

   timing/gf-timing-wait.hpp
   timing/gf-timing-clock.hpp
   timing/gf-slow-down.hpp

   core/gf-spi.hpp
   core/gf-i2c.hpp

   ostream/gf-stream
   ...

   char-io/gf-terminal.hpp
   char-io/gf-terminal-demos.hpp

//   graphics/gf-window.hpp
//   graphics/gf-drawables.hpp
//   graphics/gf-window-demos.hpp

   chips/gf-servo.hpp
   chips/gf-hd44780.hpp
   chips/gf-hc595.hpp
   chips/gf-pcf8574.hpp
//   chips/gf-pcf8591.hpp
//   chips/gf-ssd1306.hpp
   chips/gf-nrf24l01.hpp

C++20 (GCC 10) required

refresh error flags list

pullup from adapters => pins, or even to core (shared by ports)?
should pullup also be buffered??

should pullup be propagated by port?

// ?? why is this needed?
template< can_output T > struct box_out; (box adapters)

term: interface-oriented (concept-oriented)

file naming: gf-core-*; maybe put everything back in one directory?

should the HAL pop the warning settings??

Get back to your code after some time.
Add comments to explain it in simple terms.
Make the identifiers match those terms.
Remove the comments.
box_init_filter<> => box_only_init<>
It IS a filter, that is how it works, but that is the wrong name.
What it DOES for the using code is passing only a specific part.
When in doubt about naming: forget the implementation, read where it is used.
if you need a comment THERE, the name is wrong.

thing-name variations are needed for the:
- is_thing             (user) concept
- be_thing_root        (lib/HAL writer) root class
- be_thing             (HAL writer) creator that makes the thing from a HAL-provided base
- is_thing_root thing  (HAL writer) concept for that HAL-provided base
- make_thing?          (user) decorator/adapter that makes the thing from a related thing or set of things
- can_thing?           (all) can be made into a thing

color : concept
color : default color? or is that rgb24? rgb32?

When in doubt how to implement an ADT or driver interface:
- write an interface that specifies as little as possible
- write an implementation
- write the library to the interface, not the implementation

tag: is_thing_tag ? now only is_thing

check die lezing @ code dive voor naamgeving?

the name filter is exactly the wronmg way round??
box buffered requires default constructor & assignment
=> put that as requirement in box?

add as-value, subrange


loop< 8 >([]{

})

add hwlib::work to godafoss? defeats the static call-tree....
I must up-propagate the work via the init

making sure all inits are called is error-prone,
but it vcan be *checked* by an external tool
=> the tool's output is not part of the build
(contrary to stack size calculation)


template< can_gpo _pin >
struct {
   using pin = make_gpo< _pin >;

   using init = inits< pin >;
   static void init(){
      pin.write( 0 );
   }

   static void work(){
      if ...
      if ...
   }

can a lambda capture private statics???
non-capturing lambda decays to a function pointer
-> three types: init, work, main

   using minions = minion_list<
      pin,                           // has a minions
      init< []{ pin.write( 0 ); }>,  // a function to be called once
      timing::main< loop >           // a thread body
                                     // a one-shot worker
                                     // etc: other workers, defined by the scheduler
   >;

   static void loop(){
      for(;;){
         timing::ms< 500 >::wait();
         pin.write( 1 );
      }
   }

I can't write the main the nornmal way, with a loop => doesn't serve the threads or one-shots

can I find out whether sometghing needs a thread, or can do with a one-shot?
can decide on a per-cto base, or from tool analysis....

main(){
   using led = target::d2;
   using minions = blink< led, timing::ms< 100 >>;
   minions::run();
}

Can I restrict the functions used in a main or init or repeated?
repeated should not use wait (only wait_busy when realy needed)
=> can do that with tooling...

main(){
   using led = target::d2;
   timing::main< []{
      for(;;){
         timing::ms< 500 >::wait();
         ...
   } >::run();
}

TOOLING
preferred way: use tooling to check conformance
treat this like malformed-NDR, but the req. are outside the language

Is the call the run-to-completion from the waits possible (CRTP?)

todo
- check void return types (core & box)
- check xy iterator
- pullup/down should survive pin adapters
- pullup<> decorator
- pin_in from adc for my-first-devboard
- mfd: walk / select color, speed
- mfd: board test
- mfd: dimming demo
- can_pin_out etc. don't work?? in pin adapters
- 8574 + LCD
- mirror for ports, demo
- servo demo with NRF
- cout has no << flush??
- range adt
- hwlib i2c aanpasen, overnemen
-0 check https://github.com/olikraus/u8g2/wiki

- wouter / hbo-ict
- embedded
- my embedded niche
- C/C++ styles
- features to avoid
- low-hanging fruit
- dependency injection, #define/names, identifiers/parameters, objects/contsructors, classes/templates
- concepts
- test syntax versus test intended semantics
- abstractions: pins, ports, timing
- additive filters / limitative filters
- performance aspects: injection styles, buffering
- I2C & SPI: channel/transaction
- timing abstraction, small delays
- remaining issues: C++ user-defined template parameters
- how to print without std::cout
- problem with CRTP
- remaining issues: users, abstractions, timing, testing, documentation (doxygen doesn't work)

development board 2.0
blue pill
switches
4x4 keypad / 5x4?
LCD / oled
beeper
2 x AA battery
IR RX, TX
options
NRF905/2401
MPU6050
SRF04
ESP8266
memory card?? eeprom chip
LCD met touch
smartpixel  3/4 pin output
LDR
DHT11
dallas (5V)
I2C
2 x joystick

GCC 10 on Arch

download https://developer.arm.com/-/media/Files/downloads/gnu-rm/9-2020q2/gcc-arm-none-eabi-9-2020-q2-update-src.tar.bz2?revision=e2232c7c-4893-46b6-b791-356bdc29fd7f&la=en&hash=8E864863FA6E16582633DEABE590A7C010C8F750
from https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads
unpack it to a build directory
there: git clone git://gcc.gnu.org/git/gcc.git

github.com/MikeLankamp/fpm


