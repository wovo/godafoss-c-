// =============================================================================
//
// gf-random.hpp
//
// =============================================================================
//
// This file is part of godafoss (https://github.com/wovo/godafoss),
// a C++ library for close-to-the-hardware programming.
//
// Copyright
//    Wouter van Ooijen 2018-2020
//
// Distributed under the Boost Software License, Version 1.0.
// (See the accompanying LICENSE_1_0.txt in the root directory of this
// library, or a copy at http://www.boost.org/LICENSE_1_0.txt)
//
// =============================================================================
//
// @title random
//
// This is simple 32-bit LCG random function, for demos and games.
// The random facilities of the standard library are not used because
// they eat up too much RAM. Do NOT use this for crypto work.
//
// The LCG used is the Microsoft Visual/Quick C/C++ variant as explained
// on https://en.wikipedia.org/wiki/Linear_congruential_generator, but
// using bits 8..23 rather than 16..30.
//
// @bar
// @define godafoss::random16
// @insert random16
// The random16() function returns a 16-bit non-negative pseudo-random number.
//
// @bar
// @define godafoss::random32
// @insert random32
// The random32() function returns a 32-bit non-negative pseudo-random number.
//
// @bar
// @define godafoss::random_in_range
// @insert random_in_range
// The random_in_range() function returns a non-negative pseudo-random number
// in the range [ first .. last ].
// This number is calculated from a number generated by random32
// by modulo arithmetic.
// This is simple and fast, but the distribution is not ideal:
// the higher values in the range will be somewhat underrepresented.
// When the width of the range is much smaller than 2^32 this
// effect will be small.
//
// @bar
// @define godafoss::random_seed
// @insert random_seed
// The random_seed() function sets the start for the value
// returned by subsequent random calls.
// It can be used to re-start a random sequence, or (when you have
// a truely random source) to start a truely random random sequence.
//
// =============================================================================

template< typename T = void >
struct seed {
   static inline uint32_t _random_seed = 0;
};

// @quote random_seed 1 ... }
void random_seed( by_const< uint32_t > x ){
   seed<>::_random_seed = x;
}

// @quote random16 1 ... }
uint16_t random16(){
   seed<>::_random_seed = seed<>::_random_seed * 214013 + 2531011;
   return ( seed<>::_random_seed >> 8 ) & 0xFFFF;
}

// @quote random32 1 ... }
uint32_t random32(){
   auto a = random16();
   auto b = random16();
   return ( static_cast< uint32_t >( a ) << 16 ) | b;
}

// @quote random_in_range 5 ... }
template< typename int_type >
int_type random_in_range(
   by_const< int_type >first,
   by_const< int_type > last
){
   static_assert( sizeof( int_type ) <= 32 );
   return first + ( random32() % ( 1 + last - first  ) );
}
