check https://en.cppreference.com/w/cpp/language/constraints for simpler concepts

bleeding edge cross compilers:
(cortex) https://freddiechopin.info/en/download/category/11-bleeding-edge-toolchain
(avr8) https://blog.zakkemble.net/avr-gcc-builds/
(avr8) https://github.com/CrustyAuklet/avr-libstdcxx/releases/tag/v10.2.0

meta-case USP ISP : 
- https://irq5.io/2017/07/25/making-usbasp-chinese-clones-usable/
- only a Windows GUI interface
- NOT avrdude compatible

compile time objects
transient objects - i2c and spi channels
value objects (adts)

main is now a bit complicated
use< t >::initialization() - won't work for complicated t, needs to be private?
uart werkt niet meer

riscv
https://github.com/riscv-mcu/GD32VF103_Firmware_Library

https://github.com/Viatorus/compile-time-printer

speerpunten:
- loop p
- ints
- string - plaatje: gitaar
- fraction p
- passing
- random p 0-> random interface?
- background (later?)
- torsor iets met plaats en afstand
- xy p
- color p
- date-and-time kalender + horloge
- template< size_t n > concept range_1_5 = ( ( n >0 ) && ( n < 6 ) );

loop: use smaller integer
make demo for loop test, with measurements


fraction: test, T/V concepts, sink concept

window decorators must use the largest of the colors and xy, not always color<>
harware SPI via de USART

document 'byte source' and byte sink interfaces (iwc, spi, nrf24)
note: arduino due i2c1 has no pull-ups, ic2 on pcb == i2c0
write book for embedded C programmers?

i2c-bus vereenvoudigen
concepts weer invoeren
is_i2c_bus concept uitbreiden

test due i2c1

bb spi opsplitsen ala i2c
bb spi voor aleen output kan sneller (bekijk assembly?)

https://github.com/cpetrich/counterfeit_DS18B20/


timing
clock timing
i1c abstraction
hardware i2c
hardware spi pins
oled spi
sam3x8e short timing klopt niet - 82 niet meegenomen??

i2c fast is now > 400 kHz!, 100kHz is ietsje te snel

due tng - alernate random source
demo N bouncing balls
demo random by snow on the display
ssd1306 half-size displays

simplfy using https://en.cppreference.com/w/cpp/types/is_same
invert a source of fraction (ADC)
ssd1306 spi
i2c channel abstraction
i2c hardware

fraction operator- ??
clock timing service, oled timings
bouncing balls demo
i2c from run-time address (bus scanner)
pin_out from window!
lcd scrolling message demo, take from
oled on lpc1114 past niet in de RAM??
db103 lpc21isp houdt de chip in reset - no serial :( -> bmptk -control

bouncing square: minimum size 1 -> 2x2 pixels!
 init() with value -> all boxes must CRTP
 init_as_input for input-output boxes??
 struct everywhere
 script that makes one giant include file
 i2c::read_transaction + i2c:read_register( reg )
 use std::byte

 test random op een cortex
 - string size should be int with max value

 bmptk modified:
- USB0 for db103
- -control for DB103 terminal command

595 flexible number of pins?
random blocks two-files project!
random is too large for an LPC1114
db103 needs two 595 board and test
db103 ADC not tested -> use PCF8591 PCB
port< > instead of port_out_from<> etc?
gpio direct werkt niet, daarmee verder
decorators have commented out requires clauses
compatible should have
all<> must now be at least two...
pin_out<> == decorator, pin_out_type (_concept) is the concept??
a torsor can be created location_t( x, y ) ??? and it is wrong!
in window-all : xy zonder <> ??
uart has no flush??
lpc1114 uart  doesn't work
lpc1114 only 12 MHz
background gebruikt nu indirection
test non-copyable, not-constructible

ubuntu notes
- sudo apt install git, codelite, python-is-python3,
   libsfml-dev, gcc-10, g++-10, gnome-terminal
- clone godafoss, bpmtk, catchorg/Catch2
- codelite startup
-> make codelite startup script
- codelite start de exe niet goed
- use 'ubuntu software' to install notepad++

- xy in hd44780 should be smaller
- component should be torsor< int > ???
- copy torsor back
- item -> value, single, atom
- ICE from windows
- check windows 'uart'
- passing should take call into account, less efficient & 'x'??
- small-scale test random embedded

files to check

   x t + basics/gf-attributes.hpp
   t + basics/gf-shared-names.hpp - must be removed!
   t + basics/gf-ints.hpp - bigint afsplitsen
   t + basics/gf-passing.hpp
   t + basics/gf-random.hpp
       basics/gf-background.hpp

   adts/gf-output-stream.hpp
   adts/gf-xy.hpp
   adts/gf-color.hpp

   t + box/gf-box.hpp
    + box/gf-box-inherit.hpp
    + box/gf-box-no-inline.hpp
    + box/gf-box-invert.hpp
    + box/gf-box-direct.hpp
    + box/gf-box-buffered.hpp
    + box/gf-box-adapters.hpp

    + pins/gf-pin.hpp
   pins/gf-pin-adapters.hpp
    + pins/gf-pin-dummies.hpp
// pin-testers
   pins/gf-pin-demos.hpp

   core/gf-analog.hpp

   ports/gf-port.hpp
   ports/gf-port-adapters.hpp
   ports/gf-port-dummies.hpp
   ports/gf-port-from-pins.hpp
   ports/gf-port-demos.hpp

   timing/gf-timing-wait.hpp
   timing/gf-timing-clock.hpp
   timing/gf-slow-down.hpp

   core/gf-spi.hpp
   core/gf-i2c.hpp

   ostream/gf-stream
   ...

   char-io/gf-terminal.hpp
   char-io/gf-terminal-demos.hpp

//   graphics/gf-window.hpp
//   graphics/gf-drawables.hpp
//   graphics/gf-window-demos.hpp

   chips/gf-servo.hpp
   chips/gf-hd44780.hpp
   chips/gf-hc595.hpp
   chips/gf-pcf8574.hpp
//   chips/gf-pcf8591.hpp
//   chips/gf-ssd1306.hpp
   chips/gf-nrf24l01.hpp

C++20 (GCC 10) required

refresh error flags list

pullup from adapters => pins, or even to core (shared by ports)?
should pullup also be buffered??

should pullup be propagated by port?

// ?? why is this needed?
template< can_output T > struct box_out; (box adapters)

term: interface-oriented (concept-oriented)

file naming: gf-core-*; maybe put everything back in one directory?

should the HAL pop the warning settings??

Get back to your code after some time.
Add comments to explain it in simple terms.
Make the identifiers match those terms.
Remove the comments.
box_init_filter<> => box_only_init<>
It IS a filter, that is how it works, but that is the wrong name.
What it DOES for the using code is passing only a specific part.
When in doubt about naming: forget the implementation, read where it is used.
if you need a comment THERE, the name is wrong.

thing-name variations are needed for the:
- is_thing             (user) concept
- be_thing_root        (lib/HAL writer) root class
- be_thing             (HAL writer) creator that makes the thing from a HAL-provided base
- is_thing_root thing  (HAL writer) concept for that HAL-provided base
- make_thing?          (user) decorator/adapter that makes the thing from a related thing or set of things
- can_thing?           (all) can be made into a thing

color : concept
color : default color? or is that rgb24? rgb32?

When in doubt how to implement an ADT or driver interface:
- write an interface that specifies as little as possible
- write an implementation
- write the library to the interface, not the implementation

tag: is_thing_tag ? now only is_thing

check die lezing @ code dive voor naamgeving?

the name filter is exactly the wronmg way round??
box buffered requires default constructor & assignment
=> put that as requirement in box?

add as-value, subrange


loop< 8 >([]{

})

add hwlib::work to godafoss? defeats the static call-tree....
I must up-propagate the work via the init

making sure all inits are called is error-prone,
but it vcan be *checked* by an external tool
=> the tool's output is not part of the build
(contrary to stack size calculation)


template< can_gpo _pin >
struct {
   using pin = make_gpo< _pin >;

   using init = inits< pin >;
   static void init(){
      pin.write( 0 );
   }

   static void work(){
      if ...
      if ...
   }

can a lambda capture private statics???
non-capturing lambda decays to a function pointer
-> three types: init, work, main

   using minions = minion_list<
      pin,                           // has a minions
      init< []{ pin.write( 0 ); }>,  // a function to be called once
      timing::main< loop >           // a thread body
                                     // a one-shot worker
                                     // etc: other workers, defined by the scheduler
   >;

   static void loop(){
      for(;;){
         timing::ms< 500 >::wait();
         pin.write( 1 );
      }
   }

I can't write the main the nornmal way, with a loop => doesn't serve the threads or one-shots

can I find out whether sometghing needs a thread, or can do with a one-shot?
can decide on a per-cto base, or from tool analysis....

main(){
   using led = target::d2;
   using minions = blink< led, timing::ms< 100 >>;
   minions::run();
}

Can I restrict the functions used in a main or init or repeated?
repeated should not use wait (only wait_busy when realy needed)
=> can do that with tooling...

main(){
   using led = target::d2;
   timing::main< []{
      for(;;){
         timing::ms< 500 >::wait();
         ...
   } >::run();
}

TOOLING
preferred way: use tooling to check conformance
treat this like malformed-NDR, but the req. are outside the language

Is the call the run-to-completion from the waits possible (CRTP?)

todo
- check void return types (core & box)
- check xy iterator
- pullup/down should survive pin adapters
- pullup<> decorator
- pin_in from adc for my-first-devboard
- mfd: walk / select color, speed
- mfd: board test
- mfd: dimming demo
- can_pin_out etc. don't work?? in pin adapters
- 8574 + LCD
- mirror for ports, demo
- servo demo with NRF
- cout has no << flush??
- range adt
- hwlib i2c aanpasen, overnemen
-0 check https://github.com/olikraus/u8g2/wiki

- wouter / hbo-ict
- embedded
- my embedded niche
- C/C++ styles
- features to avoid
- low-hanging fruit
- dependency injection, #define/names, identifiers/parameters, objects/contsructors, classes/templates
- concepts
- test syntax versus test intended semantics
- abstractions: pins, ports, timing
- additive filters / limitative filters
- performance aspects: injection styles, buffering
- I2C & SPI: channel/transaction
- timing abstraction, small delays
- remaining issues: C++ user-defined template parameters
- how to print without std::cout
- problem with CRTP
- remaining issues: users, abstractions, timing, testing, documentation (doxygen doesn't work)

targets
- cortex M
- ESP32
- RISC V
- AVR8
- Raspberry Pi https://github.com/rsta2/circle (C: https://github.com/bztsrc/raspi3-tutorial)

have only one type of timing?
target provides the run, hence the target is always initialized? 0- fails for configurable target - no

development board 2.0
blue pill
switches
4x4 keypad / 5x4?
LCD / oled
beeper
2 x AA battery
IR RX, TX
options
NRF905/2401
MPU6050
SRF04
ESP8266
memory card?? eeprom chip
LCD met touch
smartpixel  3/4 pin output
LDR
DHT11
dallas (5V?)
I2C
2 x joystick

GCC 10 on Arch

download https://developer.arm.com/-/media/Files/downloads/gnu-rm/9-2020q2/gcc-arm-none-eabi-9-2020-q2-update-src.tar.bz2?revision=e2232c7c-4893-46b6-b791-356bdc29fd7f&la=en&hash=8E864863FA6E16582633DEABE590A7C010C8F750
from https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads
unpack it to a build directory
there: git clone git://gcc.gnu.org/git/gcc.git

github.com/MikeLankamp/fpm


template< can_pin _a, timing t >
struct srf04 {
   using a = pin_out< _a >;
   static void init(
      do something
   }
   using resources = use< a, t >;

}

run< blink< target::p1, target::timing > >()

task has priority, stack size (for now)



struct resource_sentinel {
   using tasks = task_sentinel;
   using background = background_sentinel;
   using inits = init_sentinel;
};


template< can_pin_out _pin, can_static_duration _pause >
struct blink {

   using pin = direct< pin_out_from< _pin >>;
   using pause = static_duration< _pause >;

   using resources = resources< pin, pause >;

   static void GODAFOSS_NO_RETURN run(){
      for(;;){
         pin::write( 1 );
         pause::wait();
         pin::write( 0 );
         pause::wait();
      }
   }
};

template< application >
struct run {
   static void GODAFOSS_NO_RETURN run(){
      - call all inits
      - start threading
      application::run();
   }
};

int main(){
   <hoe vind je de naam van wat er gerunt moet worden?
}

- je kan twee apps mergen, dan worden ze tasks
